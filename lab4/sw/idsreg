#!/usr/bin/perl -w
use lib "/usr/local/netfpga/lib/Perl5";
use strict;

# --- Address Definitions (Matching reg_defines_lab4.h) ---
my $IDS_PATTERN_HI_REG = 0x2000300;
my $IDS_PATTERN_LO_REG = 0x2000304;
my $IDS_COMMAND_REG    = 0x2000308;
my $IDS_MATCHES_REG    = 0x200030c;

# --- Register Write Function ---
sub regwrite {
   my( $addr, $value ) = @_;
   my $cmd = sprintf( "regwrite 0x%08x 0x%08x", $addr, $value );
   my $result = `$cmd`;
   printf ("addr 0x%08x value 0x%08x\n", $addr, $value);
   print "$cmd\n";
}

# --- Register Read Function ---
sub regread {
   my( $addr ) = @_;
   my $cmd = sprintf( "regread 0x%08x", $addr );
   print "cmd= $cmd\n";
   my @out = `$cmd`;
   print "out = @out\n";
   my $result = $out[0] || "";
   print "result= $result\n";
   # Parse the output string to extract the hex value
   if ( $result =~ m/Reg (0x[0-9a-f]+) \((\d+)\):\s+(0x[0-9a-f]+) \((\d+)\)/ ) {
      $result = $3;
   }
   return $result;
}

sub idsreset {
   regwrite( $IDS_COMMAND_REG, 0x1 );
   regwrite( $IDS_COMMAND_REG, 0x0 );
}

sub write_pattern {
   my($hi, $lo) = @_;
   regwrite($IDS_PATTERN_HI_REG, $hi);
   regwrite($IDS_PATTERN_LO_REG, $lo);
}

# Turns an ascii string into a (pattern_hi,pattern_low) list
sub pattern_from_ascii {
   my( $patstr ) = @_;
   my @chars = split(//, $patstr);
   my @ints = map {  ord( $_ ) } @chars;
   my $validBytes = $#ints + 1;
   my $hi = 0;
   my $lo = 0;
   for (my $i = 0; $i <= 6; $i++) {
      if ($i < $validBytes) {
         my $bit = 1 << (6 - $i);
         $hi |= ($bit << 24);
         if ($i <= 2) {
            $hi |= ($ints[$i] << (8 * (2 - $i)));
         } else {
            my $pos = $i - 3;
            $lo |= ($ints[$i] << (8 * (3 - $pos)));
         }
      }
   }
   return ($hi, $lo);
}

sub usage {
   print "Usage: idsreg <cmd> <cmd options>\n";
   print "  Commands:\n";
   print "    write 0x<val>      Direct write for testing (Phase 1: Byte Reverse)\n";
   print "    read               Read and display result (Phase 1: Byte Reverse)\n";
   print "    reset              Reset the matches counter\n";
   print "    pattern <string>   Set the ASCII pattern to match\n";
   print "    matches            Display the matches counter\n";
   print "    allregs            Display status of all IDS registers\n";
}

# --- Main Logic ---
my $numargs = $#ARGV + 1;
if( $numargs < 1 ) {
   usage();
   exit(1);
}

my $cmd = $ARGV[0];

if ($cmd eq "write") {
   if ($numargs < 2) { usage(); exit(1); }
   my $val = hex($ARGV[1]);
   print "Writing $ARGV[1] to IDS Register (0x2000300)...\n";
   regwrite($IDS_PATTERN_HI_REG, $val);

} elsif ($cmd eq "read") {
   my $val = regread($IDS_PATTERN_HI_REG);
   print "Read from IDS (Byte Reversed): $val\n";

} elsif ($cmd eq "reset") {
   idsreset();
   print "IDS Counter Reset.\n";

} elsif ($cmd eq "pattern") {
   if ($numargs < 2) { usage(); exit(1); }
   my $str = $ARGV[1];
   my($hi, $lo) = pattern_from_ascii($str);
   printf("Setting pattern hi=0x%08x, lo=0x%08x\n", $hi, $lo);
   write_pattern($hi, $lo);   

} elsif ($cmd eq "matches") {
   my $matches = regread( $IDS_MATCHES_REG );
   print "Matches Counter: $matches\n";

} elsif ($cmd eq "allregs") {
   print "------------------------------------\n";
   print "MATCHES:    ", regread( $IDS_MATCHES_REG ), "\n";
   print "PATTERN_HI: ", regread( $IDS_PATTERN_HI_REG ), "\n";
   print "PATTERN_LO: ", regread( $IDS_PATTERN_LO_REG ), "\n";
   print "COMMAND:    ", regread( $IDS_COMMAND_REG ), "\n";
   print "------------------------------------\n";

} else {
   print "Unrecognized command: $cmd\n";
   usage();
   exit(1);
}
